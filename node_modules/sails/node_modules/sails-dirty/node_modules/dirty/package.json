{
  "name": "dirty",
  "description": "A tiny & fast key value store with append-only disk log. Ideal for apps with < 1 million records.",
  "version": "0.9.6",
  "dependencies": {},
  "main": "./lib/dirty",
  "devDependencies": {
    "gently": ">=0.8.0"
  },
  "engines": {
    "node": "*"
  },
  "readme": "# node-dirty\n\n## Purpose\n\nA tiny & fast key value store with append-only disk log. Ideal for apps with < 1 million records.\n\n## Installation\n\n    npm install dirty\n\n## Why dirty?\n\nThis module is called dirty because:\n\n* The file format is newline separated JSON\n* Your database lives in the same process as your application, they share memory\n* There is no query language, you just `forEach` through all records\n\nSo dirty means that you will hit a very hard wall with this database after ~1 million records,\nbut it is a wonderful solution for anything smaller than that.\n\n## Tutorial\n\n    require('../test/common');\n    var db = require('dirty')('user.db');\n\n    db.on('load', function() {\n      db.set('john', {eyes: 'blue'});\n      console.log('Added john, he has %s eyes.', db.get('john').eyes);\n\n      db.set('bob', {eyes: 'brown'}, function() {\n        console.log('User bob is now saved on disk.')\n      });\n\n      db.forEach(function(key, val) {\n        console.log('Found key: %s, val: %j', key, val);\n      });\n    });\n\n    db.on('drain', function() {\n      console.log('All records are saved on disk now.');\n    });\n\nOutput:\n\n    Added john, he has blue eyes.\n    Found key: john, val: {\"eyes\":\"blue\"}\n    Found key: bob, val: {\"eyes\":\"brown\"}\n    User bob is now saved on disk.\n    All records are saved on disk now.\n\n## API\n\n### new Dirty([path])\n\nCreates a new dirty database. If `path` does not exist yet, it is created. You\ncan also omit the `path` if you don't want disk persistence (useful for testing).\n\nThe constructor can be invoked in multiple ways:\n\n    require('dirty')('my.db');\n    require('dirty').Dirty('my.db');\n    new (require('dirty'))('my.db');\n    new (require('dirty').Dirty)('my.db');\n\n### dirty.path\n\nThe path of the dirty database.\n\n### dirty.set(key, value, [cb])\n\nSet's the given `key` / `val` pair. The state of the database is affected instantly,\nthe optional `cb` callback is fired when the record was written to disk.\n\n`val` can be any JSON-serializable type, it does not have to be an object.\n\n### dirty.get(key)\n\nRetrieves the value for the given `key`.\n\n### dirty.rm(key, cb)\n\nRemoves the record with the given `key`. This is identical to setting the `key`'s value\nto `undefined`.\n\n### dirty.forEach(fn)\n\nCalls the given `fn` function for every document in the database. The passed\narguments are `key` and `val`. You can return `false` to abort a query (useful\nif you are only interested in a limited number of records).\n\nThis function is blocking and runs at ~4 Mhz.\n\n### dirty event: 'load' (length)\n\nEmitted once the database file has finished loading. It is not safe to access\nrecords before this event fires. Writing records however should be fine.\n\n`length` is the amount of records the database is holding. This only counts each\nkey once, even if it had been overwritten.\n\n### dirty event: 'drain' ()\n\nEmitted whenever all records have been written to disk.\n\n## License\n\nnode-dirty is licensed under the MIT license.\n",
  "readmeFilename": "README.md",
  "_id": "dirty@0.9.6",
  "_from": "dirty@0.9.6"
}
